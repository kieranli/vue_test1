<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>var、let、const的区别</title>
</head>

<body>
    <!-- 

        作用域：
        JS中作用域有：全局作用域、函数作用域。没有块作用域的概念。ECMAScript 6(简称ES6)中新增了块级作用域。
        块作用域由 { } 包括，if语句和for语句里面的{ }也属于块作用域。

        var、let、const的区别：
        使用var声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象,即可以跨块访问，但不能跨函数访问
        使用let声明的变量，其作用域为该语句所在的代码块内，不存在变量提升；
        使用const声明的可以看作常量，但并不是指变量值不可改变，而是变量和的内存地址不可改变。创建了不可变的绑定，其内部内容可变，变量标识符不能重新分配，即不能转换为另外一种类型。
        若区块中存在let或者const,则这个区块对这些变量和常量在一开始就行成封闭作用域，只要在声明之前使用就会报错
        
        变量提升：
        当栈内存（作用域）形成的，js代码自上而下执行之前，浏览器首先会把带有 “var”、"function"关键字的进行提前“声明”或“定义“
        <编译>阶段会将其放在当前作用域最前面，<执行>阶段才会按顺序执行
        这种预先处理的机制就是变量提升。
        声明（declare）：var a ; (声明的时候 默认返回值是undefined)
        定义（defined）：a=12 （定义也可以简单理解为赋值）
    -->

    <!-- 经典示例 -->
    <script type="text/javaScript">
        // 以下输出0-9，为区别二者，后续添加定时器
        for(var i=0;i<10;i++){
                console.log(i);
        };
        // 以下输出10个10
        for(var i=0;i<10;i++){
            setTimeout(function(){
                console.log(i);
            },100)
        };
        // 以下输出0-9
        for(let i=0;i<10;i++){
            setTimeout(function(){
                console.log(i);
            },100)
        };
    </script>
    <!-- 
        分析：var首先带来了变量提升,将i提升到全局变量,所以var命令实际上只执行了一次
        let命令不存在变量提升,所以在每次for循环执行中let都会执行一次，let块级作用域锁区,所以当前的作用域内也只有一个i，
        所以每个setTimeout中的i值都指向了不同的值。
        for的循环机制决定了它每次循环都是不同的块级作用域(这里与let声明块级作用域吻合) 
        -->
</body>

</html>